# Stockfolio 비디오 편집기 API

## 목차

[프로젝트 내용](#프로젝트-개요)  
[API 사용설명서](#비디오-편집-api-문서)  
[작업 타임라인](#타임라인)


## 프로젝트 목표 : 
### ffmpeg를 사용하여 동영상 편집 기능을 제공하는 HTTP API 개발 
### 사용자가 동영상을 업로드하고, 특정 구간을 잘라내며, 여러 동영상을 결합할 수 있는 기능을 구현

## 프로젝트 개요
- 사용자가 여러 동영상을 업로드하고 트림(컷 편집)과 이어붙이기 작업을 수행할 수 있도록 설계된 API
- 사용자의 요청에 따라 배치 처리 방식을 채택

## 구현된 기능
### 1. 동영상 업로드
- 사용자가 일반적인 형식의 동영상을 업로드할 수 있도록 API 엔드포인트를 구현
- 각 동영상은 고유한 ID가 부여되어 후속 작업에서 식별 및 관리할 수 있음
### 2. 동영상 컷 편집 명령 (Trim)
- 사용자가 업로드된 동영상에서 원하는 시작 및 종료 시간을 지정하여 특정 구간을 잘라낼 수 있도록 기능을 구현
- API는 동영상 ID, 시작 시간, 종료 시간을 매개변수로 받아 처리
### 3. 동영상 이어붙이기 명령 (Concat)
- 사용자가 여러 개의 동영상을 하나로 결합할 수 있는 기능을 구현
- API는 결합할 동영상의 ID 목록을 받아 결합
### 4. 명령 작업 수행
- 모든 트림 및 이어붙이기 명령을 일괄 처리할 수 있는 기능을 구현하여, 요청된 작업을 한 번에 실행하고 성공 메시지를 반환
### 5. 최종 동영상 다운로드
- 사용자가 최종 작업 결과물인 동영상을 다운로드할 수 있도록 API에서 다운로드 링크를 제공
### 6. 동영상 및 작업 조회
- 사용자가 업로드된 동영상, 트림 요청, 이어붙이기 요청, 생성된 최종 동영상 정보를 조회할 수 있도록 엔드포인트를 구현
- 각 항목은 ID, URL, 요청 세부 정보 등을 포함

## 기술적 접근
- 개발 언어: 프로젝트는 Python으로 구현
- HTTP 메서드: RESTful 원칙에 따라 적절한 HTTP 메서드를 사용하여 API를 설계
- 오류 처리: 요청 유효성 검사 및 오류 처리를 포함하여, 적절한 HTTP 상태 코드를 반환하도록 하였음
- FFmpeg 통합: ffmpeg를 사용하여 모든 동영상 처리 작업을 수행했으며, 특히 컷 편집과 이어붙이기 작업에 중점을 두었음
- 데이터 관리: 로컬 파일 시스템과 데이터베이스를 사용하여 동영상과 관련 메타데이터를 효율적으로 관리

## 기능 개선 및 성능 최적화
- 비동기 처리: Celery와 같은 비동기 작업 큐를 활용하여 동영상 처리 작업을 백그라운드에서 실행하도록 구현
- 이를 통해 API가 즉각적으로 사용자 요청에 응답할 수 있으며, 대규모 작업도 효율적으로 처리할 수 있습니다.

# 비디오 편집 API 문서
## 개요
- 비디오 편집 API는 비디오 파일의 업로드, 자르기 및 병합 기능을 제공 
- 웹 기반 비디오 편집 서비스에서 사용하도록 설계 
- 모든 작업은 JWT 토큰을 사용한 인증이 필요

## 인증
- 모든 API 요청은 유효한 JWT 토큰을 필요 
- 토큰을 얻으려면 유효한 사용자 자격 증명을 사용하여 /api/token/ 엔드포인트를 사용

## 인증 엔드포인트
### 토큰 발급:
- URL: /api/token/
- 메서드: POST
- 설명: JWT 액세스 및 갱신 토큰을 발급받습니다.
- 요청 본문:
json
```
{
    "username": "string",
    "password": "string"
}
```

응답:

json
```
{
    "refresh": "string",
    "access": "string"
}
```

### 토큰 갱신:
- URL: /api/token/refresh/
- 메서드: POST
- 설명: 유효한 갱신 토큰을 사용하여 JWT 액세스 토큰을 갱신합니다.

- 요청 본문:

json
```
{
    "refresh": "string"
}
```

- 응답:

json
```
{
    "access": "string"
}
```

## 비디오 엔드포인트
### 비디오 목록 및 업로드
### 비디오 목록:
- URL: /api/videos/
- 메서드: GET
- 인증: 필수
- 설명: 업로드된 모든 비디오의 목록을 조회합니다.
- 응답:

json
```
[
    {
        "id": "integer",
        "file": "string",
        "create_at": "datetime"
    }
]
```

### 비디오 업로드:
- URL: /api/videos/upload/
- 메서드: POST
- 인증: 필수
- 설명: 여러 비디오 파일을 업로드합니다.
- 요청 매개변수:
- files (form data): 업로드할 비디오 파일 목록.

- 요청 예제:
- files 키에 여러 비디오 파일이 포함된 form-data.

- 응답:

json
```
[
    {
        "id": "integer",
        "file": "string",
        "create_at": "datetime"
    }
]
```

### 비디오 자르기:
- URL: /api/videos/trim/
- 메서드: POST
- 인증: 필수
- 설명: 지정된 비디오에 대한 자르기 명령을 생성합니다.
- 요청 본문:

json
```
{
    "video_no": "integer",
    "start_time": "integer",  // 시작 시간(초)
    "end_time": "integer"     // 종료 시간(초)
}
```

응답:

json
```
{
    "id": "integer"  // 생성된 자르기 명령의 ID
}
```

### 비디오 병합:
- URL: /api/videos/concat/
- 메서드: POST
- 인증: 필수
- 설명: 비디오 목록에 대한 병합 명령을 생성합니다.
- 요청 본문:

json
```
{
    "videos": ["integer", "integer", ...]  // 비디오 ID 목록
}
```

- 응답:
json
```
{
    "id": "integer"  // 생성된 병합 명령의 ID
}
```

### 비디오 다운로드:
- URL: /api/videos/<id>/download/
- 메서드: GET
- 인증: 필수
- 설명: ID로 특정 비디오 파일을 다운로드합니다.
- 응답:
  - Content-Type: video/mp4
  - 응답에는 비디오 파일의 바이너리 콘텐츠가 포함됩니다.
- 오류 처리
  - API는 요청의 성공 또는 실패를 나타내기 위해 표준 HTTP 상태 코드를 사용합니다. 일반적인 상태 코드는 다음과 같습니다:

    - 200 OK - 요청이 성공적으로 처리되었습니다.
    - 201 Created - 리소스가 성공적으로 생성되었습니다.
    - 400 Bad Request - 요청이 잘못되었거나 유효하지 않습니다.
    - 401 Unauthorized - 인증 자격 증명이 없거나 유효하지 않습니다.
    - 404 Not Found - 요청한 리소스를 찾을 수 없습니다.
    - 500 Internal Server Error - 서버에서 오류가 발생했습니다.

- 참고
  - JSON 본문이 포함된 요청의 경우 Content-Type 헤더를 application/json으로 설정해야 합니다.
  - upload, trim, concat 엔드포인트는 비동기식으로 작동하며 비디오 작업을 처리하기 위한 백그라운드 작업을 트리거합니다.

## Swagger 및 Redoc
### API 문서 및 인터랙티브 테스트는 Swagger와 Redoc을 통해 제공됩니다.

### Swagger UI: /swagger/에서 접근 가능
### Redoc UI: /redoc/에서 접근 가능



# 타임라인
## 2024년 8월 6일 
- ffmpeg 관련 공부
- 주요 기능 및 기능별 구현 구조 확립

- 테스트 진행시 
- id : admin
- 비번 : ***


## 2024년 8월 7일

- 프로젝트 환경 설정**
  - Django 프로젝트와 앱 생성
  - `djangorestframework`와 `drf-yasg`를 사용하여 API 개발 환경 구축
  - `djangorestframework-simplejwt`를 사용하여 JWT 인증 설정 완료

- 모델 및 시리얼라이저 설정**
  - `Video`, `TrimCommand`, `ConcatCommand` 모델 정의
  - 모델에 대한 시리얼라이저 작성 (`VideoSerializer`, `TrimCommandSerializer`, `ConcatCommandSerializer`, `VideoUploadSerializer`)

- API 엔드포인트 구현**
  - `VideoViewSet`을 생성하여 비디오 업로드, 트림, 병합, 다운로드 기능 구현
  - 파일 업로드를 위해 `MultiPartParser`와 `FormParser` 추가
  - Celery를 사용하여 비디오 트림 및 병합 작업을 비동기로 처리

- Swagger 설정 및 디버깅**
  - `swagger_auto_schema`를 사용하여 Swagger 문서화 개선
  - Swagger UI에서 파일 업로드가 작동하지 않는 문제 해결 시도
  - 멀티파트 폼 데이터 처리와 관련된 오류 수정
  - 로깅 설정 추가하여 디버깅 과정 중 유용한 정보를 출력

- 테스트 케이스 작성 및 실행**
  - Django `TestCase`를 사용하여 API 테스트 케이스 작성
  - JWT 인증과 관련된 테스트 구현
  - 비디오 업로드, 트림 및 다운로드 기능의 테스트 성공 확인

- 버그 수정 및 최종 테스트**
  - Celery 작업에서 발생하는 예외 처리 추가
  - `ConcatCommand`와 `TrimCommand` 실행 중 발생하는 문제 해결
  - 최종적으로 Swagger UI에서 모든 엔드포인트가 예상대로 작동하는지 확인

## 프로젝트 주요 성과
- Django와 DRF를 사용하여 기본적인 비디오 편집 API를 구현
- JWT를 활용한 인증 및 권한 관리
- Swagger를 통해 API 문서화 및 테스트 환경 제공
- Celery를 통한 비동기 작업 처리


## 2024년 8월 8일

### 비디오 병합 작업 요약

### 개요
이 문서는 Django 환경에서 Celery를 사용하여 FFmpeg로 비디오 파일을 병합하는 작업과 관련된 문제 해결을 위해 수행된 작업과 진단 단계를 요약

### 수행된 작업
- **비디오 병합**: 여러 가지 명령 옵션과 Python 스크립트를 사용하여 FFmpeg로 두 개의 MP4 비디오 파일을 병합하려고 시도

### 문제 해결 단계
1. **FFmpeg 명령어 검증**: 터미널에서 직접 FFmpeg 명령어를 실행하여 문법과 매개변수가 올바른지 확인하였습니다. 이는 Django 환경으로부터 문제를 분리하는 데 도움이 되었습니다.

2. **코드 조정**: 비디오 병합을 처리하는 Python 스크립트를 여러 차례 조정하여 모든 경로와 명령이 정확하게 설정되었는지 확인하였습니다.

3. **파일 속성 일관성**: 입력 비디오 파일이 코덱, 프레임 레이트, 해상도에서 일관성을 유지하도록 확인하여 병합 과정 중 문제를 방지하였습니다.

4. **명령줄 직접 테스트**: 스크립트 오류를 우회하고 기본 FFmpeg 기능이 예상대로 작동하는지 검증하기 위해 명령줄에서 직접 FFmpeg 명령어를 실행하였습니다.

5. **오류 처리 및 로깅 개선**: 디버깅 목적으로 보다 자세한 정보를 캡처하고 기록하기 위해 스크립트 내의 오류 처리 및 로깅을 개선했습니다.

## 사용된 FFmpeg 병합 명령어

ffmpeg -f concat -i input.txt -c copy output.mp4

### 직접 명령어 작성시 작동하였고 작동하였던 명령어를 통해 tasks.py 코드 수정
### 수정 후 작동 완료

## 2024년 8월 9일

### 비디오 Concat 작업 요약 (순서 관리)

- 비디오 파일들의 병합 처리 과정에서 정렬 순서를 보장하기 위해 입력 순서를 관리 시도 -> 기존에 잘 작동하던 병합도 작동되지 않음


## 2024년 8월 10일

### 비디오 Concat 기능 수정
- 2024년 8월 9일 진행하였던 작업을 원상태로 복구 시켜 다시 작업 -> 기능 작동
- 다양한 방법으로 비디오 입력시 정렬 순서를 보장하기 위해 시도 (진행하였던 방법 : 아래 내용)
1. **텍스트 파일을 생성하여 파일명 입력 후 ffmpeg 명령어를 통해 직접 비디오 병합**
2. **모델과 serializer, view, task 모두를 수정하여 사용자가 비디오 입력한 순서를 받아 직접 전달**
3. **txt파일 확인 후 ffmpeg 명령어 실행**

- 그러나 결론적으로 모두 사용자가 입력한 순서와 상관 없이 같은 순서로 정렬되어 새 비디오 생성 병합은 작동


## 2024 8월 11일
### 비디오 Trim 기능 수정
- Trim이 기능의 오류 수정 -> 기능 작동하나 -t *(종료 시간)부분만 작동
- ss(시작 시간) 기능이 작동하지 않음
1. **명령어 변경**
2. **로직 변경**

- 결론적으로 종료 시간만 인식


## 2024년 8월 12일
### 전체적인 기능 확인 및 계속하여 오류 수정을 위해 노력
- VScode의 캐시로 인해 수정하였던 내용이 반영되지 않음을 확인
- VScode와 서버를 종료 후 재시작하여 수정된 내용 반영되는 것을 확인
- Trim 관련 로직 변경으로 인한 tests.py 코드 수정
